struct Command {
    worker_id: int,
    request: bool,
    query: bool,
    disconnect: bool
}

struct Response {
    worker_id: int,
    value: bool,
    disconnect: bool
}

struct Worker {
    id: int,
    busy: bool
}

function xor(a: bool, b: bool, c: bool) -> bool {
    result == ((a or b or c) and not ((a and b) or (b and c) or (a and c)));
}

function active(c :Command) -> bool {
    result == true;
}

function int_active(id :int) -> bool {
    result == true;
}

reactor manager(input: stream Command) {
    //output: stream Response =
    resource_unavailable: stream bool = true @ (request and not assigned_worker_id);
private:
    workerA: cell Worker = Worker(0,false) .. Worker(0,true)  if assigned_worker_id == workerA.id
                                            | Worker(0,false) if released_worker_id == workerA.id;
    request: stream Command = input if input.request;//==true;
    query: stream Command = input if input.query;
    disconnect: stream Command = input if input.disconnect;

    assigned_worker_id: stream int = (workerA.id @ request) if not workerA.busy;
    released_worker_id: stream int = workerA.id @ disconnect if workerA.busy;

    count: cell int = 0 .. count + ( 1 @ assigned_worker_id
                                   |-1 @ released_worker_id);
properties:
    //good: G(active(input) -> xor(input.request, input.query, input.disconnect)) -> not F int_active(released_worker_id));
    //good: G(active(input) -> xor(input.request, input.query, input.disconnect)) -> false;
    //good: G((true @ input) -> xor(input.request, input.query, input.disconnect)) -> not F true @ resource_unavailable;
    good: G((true @ input) -> xor(input.request, input.query, input.disconnect)) -> G ((true @ resource_unavailable) -> (count==1));
}