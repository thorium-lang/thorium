struct Command {
    worker_id: int,
    request: bool,
    query: bool,
    disconnect: bool
}

struct Response {
    worker_id: int,
    reply: bool,
    disconnect: bool
}

reactor Worker(id: cell int, input: stream Command) {
    assigned:  stream int      = ID @ input if input.request and not busy;
    released:  stream int      = ID @ input if input.disconnect and input.worker_id==ID;
    response:  stream Response = Response(ID, true, false) if busy and input.query
                               | Response(ID, false, true) if released;
    unhandled: stream Command  = input if not unit(assigned or released or response);

    ID: cell int = id .. 1 @ input if false;
private:
    busy: cell bool = false .. true  @ assigned
                             | false @ released
}

function simultaneous(a: bool, b: bool, c: bool) -> bool {
    result == ((a and b) or (b and c) or (a and c));
}

reactor manager(input: stream Command) {
    resource_unavailable: stream unit = unit(request and not assigned_worker_id);
    response: stream Response = workerA.response | workerB.response | workerC.response;
private:
    request:    stream Command = input if input.request;

    workerA: cell Worker = Worker(0, input);
    workerB: cell Worker = Worker(1, workerA.unhandled);
    workerC: cell Worker = Worker(2, workerB.unhandled);

    assigned_worker_id: stream int = workerA.assigned | workerB.assigned | workerC.assigned;
    released_worker_id: stream int = workerA.released | workerB.released | workerC.released;

    count: cell int = 0 .. count + ( 1 @ assigned_worker_id
                                   |-1 @ released_worker_id);
properties:
    diligent: G not simultaneous (input.request, input.query, input.disconnect) =>
                  G (resource_unavailable => (count==3));
    orderly: G not simultaneous (input.request, input.query, input.disconnect) =>
                  G ((workerA.response.reply) => ((not workerA.response.disconnect) S (assigned_worker_id==workerA.ID)));
}